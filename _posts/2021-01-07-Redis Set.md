---   
### 集合编码   
集合对象的底层数据结构有两种：intset 和 hashtable。内部通过编码来进行区分：      
   
| 编码属性	            | 描述	                        | object encoding 命令返回值 |    
|-----------------------|-------------------------------|-------------|   
| OBJ\_ENCODING\_INTSET	| 使用整数集合实现的集合对象	| intset |    
| OBJ\_ENCODING\_HT	    | 使用字典实现的集合对象	    | hashtable |   
   
### intset   
   
intset（整数集合）可以保存类型为 int16\_t、int32\_t、int64\_t 的整数值，并且保证集合中没有重复元素。   
   
intset 数据结构定义如下（源码 inset.h 内）：   
   
```c++    
typedef struct intset {   
    uint32_t encoding;//编码方式   
    uint32_t length;//当前集合中的元素数量   
    int8_t contents[];//集合中具体的元素   
} intset;   
```   
下图就是一个 intset 的集合对象简图：   
<div align="left">      
    <img src="/images/redis_intset01.png" width="80%">      
</div>      
   
* encoding   
   
在 intset 内部的 encoding 记录了当前整数集合的数据存储类型，主要有三种：   
   
INTSET\_ENC\_INT16：此时 contents[] 内的每个元素都是一个 int16\_t 类型的整数值，范围是：-32768 ~ 32767（-2 的 15 次方 ~ 2 的 15 次方 - 1）。   
INTSET\_ENC\_INT32：此时 contents[] 内的每个元素都是一个 int32\_t 类型的整数值，范围是：-2147483648 ~ 2147483647（-2 的 31 次方 ~ 2 的 31 次方 - 1）。   
INTSET\_ENC\_INT64：此时 contents[] 内的每个元素都是一个 int64\_t 类型的整数值，范围是：-9223372036854775808 ~ 9223372036854775807（-2 的 63 次方 ~ 2 的 63 次方 - 1）。   
contents[]   
   
contents[] 虽然结构上的定义写的是 int8\_t 类型，但实际存储类型是由上面的 encoding 来决定的。   
   
* 整数集合的升级   
   
假如一开始整数集合中的元素都是 16 位的，采用了 int16\_t 类型来存储，此时需要再存储一个 32 位的整数，那么就需要对原先的整数集合进行升级，升级之后才能将 32 位的整数存储到整数集合内。这就涉及到了整数集合的类型升级，升级过程主要有 4 个步骤：   
   
根据新添加元素的类型来扩展底层数组空间的大小，按照升级后现有元素的位数来分配新的空间。   
将现有的元素进行类型转换，并将转换类型后的元素从后到前逐个重新放回到数组内。   
将新元素放到数组的头部或者尾部（因为触发升级的条件就是当前数组的整数类型无法存储新元素，所以新元素要么比现有元素都大，要么就比现有元素都小）。   
将 encoding 属性修改为最新的编码，并且同步修改 length 属性。   
PS：和字符串对象的编码一样，整数集合的类型一旦发生升级，将会保持编码，无法降级。   
   
### hashtable   
见：[Redis hashtable](/Redis-Hashtable)   
   
### intset 和 hashtable 编码转换   
当一个集合满足以下两个条件时，Redis 会选择使用 intset 编码：   
   
1. 集合对象保存的所有元素都是整数值。   
2. 集合对象保存的元素数量小于等于 512 个（这个阈值可以通过配置文件 set-max-intset-entries 来控制）。   

一旦集合中的元素不满足上面两个条件，则会选择使用 hashtable 编码。   


