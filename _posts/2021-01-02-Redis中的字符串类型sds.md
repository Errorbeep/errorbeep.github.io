---

Redis对字符串对象进行了特别设计，命名为sds(Simple Dynamic String)，一种二进制安全的字符串对象；
二进制安全的字符串是原始的、无任何特殊格式意义的数据流。对于每个字符都公平对待，不特殊处理某一个字符。
正因为 C 语言中是以遇到的第一个空字符 \0 来识别是否到了字符串末尾，因此其只能保存文本数据，不能保存图片、音频、视频和压缩文件等二进制数据，否则可能出现字符串不完整的问题，所以其是二进制不安全的;
Redis 中为了实现二进制安全的字符串，对原有 C 语言中的字符串实现做了改进。如下所示就是一个旧版本的 sds 字符串的结构定义：
```c++
struct sdshdr{
  int len;//记录buf数组已使用的长度，即SDS的长度(不包含末尾的'\0')
  int free;//记录buf数组中未使用的长度
  char buf[];//字节数组，用来保存字符串
}
```
经过改进之后，如果想要获取 sds 的长度不用去遍历 buf 数组了，直接读取 len 属性就可以得到长度，时间复杂度一下就变成了 O(1)，而且因为判断字符串长度不再依赖空字符 \0，所以其能存储图片、音频、视频和压缩文件等二进制数据，不用担心读取到的字符串不完整。

需要注意的是，sds 依然遵循了 C 语言字符串以 \0 结尾的惯例，这么做是为了方便复用 C 语言字符串原生的一些 API，换言之就是在 C 语言中会以碰到的第一个 \0 字符作为当前字符串对象的结尾，所以如果一些二进制数据就可能会出现读取字符串不完整的现象，而 sds 会以长度来判断是否到字符串末尾。

在 Redis 3.2 之后的版本，Redis 对 sds 又做了优化，按照存储空间的大小拆分成为了 sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64，分别用来存储大小为：32 字节（2 的 5 次方），256 字节（2 的 8 次方），64KB（2 的 16 次方），4GB 大小（2 的 32 次方）以及 2 的 64 次方大小的字符串（因为目前版本 key 和 value 都限制了最大 512MB，所以 sdshdr64 暂时并未使用到）。 sdshdr5 只被应用在了 Redis 的 key 中，value 中不会被使用到，因为 sdshdr5 和其它类型也不一样，其并没有存储未使用空间，所以比较适用于使用大小固定的场景（比如 key 值）：

sdshdr8的实现如下：
```c++
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; //已使用空间大小
    uint8_t alloc; //总共申请的空间大小(包括未使用的)
    unsigned char flags; //用来表示当前sds类型是sdshdr8还是sdshdr16等
    char buf[]; //真实存储字符串的字节数组
};
```
可以看到相比较于 Redis 3.2 版本之前的 sds，主要是修改了 free 属性然后新增了一个 flags 标记来区分当前的 sds 类型。

### sds 空间分配策略
C 语言避免缓存区溢出和内存泄露完全依赖于人为，很难把控，但是使用 sds 就不会出现这两个问题，因为当我们操作 sds 时，其内部会自动执行空间分配策略，从而避免了上述两种情况的出现。

空间预分配

空间预分配指的是当我们通过 api 对 sds 进行扩展空间时，假如未使用空间不够用，那么程序不仅会为 sds 分配必须要的空间，还会额外分配未使用空间，未使用空间分配大小主要有两种情况：

假如扩大长度之后的 len 属性小于等于 1MB （即 1024 * 1024），那么就会同时分配和 len 属性一样大小的未使用空间（此时 buf 数组已使用空间 = 未使用空间）。
假如扩大长度之后的 len 属性大于 1MB，那么就会分配 1MB 未使用空间大小。
执行空间预分配策略的好处是提前分配了未使用空间备用后，就不需要每次增大字符串都需要分配空间，减少了内存重分配的次数。

惰性空间释放

惰性空间释放指的是当我们需要通过 api 减小 sds 长度的时候，程序并不会立即释放未使用的空间，而只是更新 free 属性的值，这样空间就可以留给下一次使用。而为了防止出现内存溢出的情况，sds 单独提供给了 api 让我们在有需要的时候去真正的释放内存。

### sds 和 C 语言字符串区别

| C字符串 |	SDS |
| --------|-------- |
| 只能保存文本类不含空字符串 \0 数据 | 可以保存文本或者二进制数据，允许包含空字符串 \0 |
| 获取字符串长度的复杂度为 O(n)	| 获取字符串长度的复杂度为 O(1) |
| 操作字符串可能会造成缓冲区溢出 | 	不会出现缓冲区溢出情况 |
| 修改字符串长度 N 次，必然需要 N次内存重分配 | 	修改字符串长度 N 次，最多需要 N 次内存重分配 |
| 可以使用 C 字符串相关的所有函数 | 可以使用 C 字符串相关的部分函数 |
